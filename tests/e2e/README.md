# Cache Protocol End-to-End Tests

## Purpose

End-to-end validation of ContentCache and PersistentCache protocols in TigerVNC. Tests verify correct protocol implementation, cache hit rates, bandwidth savings, and cross-platform compatibility.

### Test Status (November 13, 2025)

**‚úÖ C++ Viewer Tests Passing:**
- `test_cpp_contentcache.py`: 63-67% hit rate, ~300 KB saved
- `test_cpp_persistentcache.py`: 100% hit rate, 99.7% bandwidth reduction, ~517 KB saved
- `test_cpp_cache_eviction.py`: Cache eviction handling verified (63% hit rate after evictions)
- `test_cache_eviction.py`: Eviction protocol working (66% hit rate, 173 hits)

**üöß Rust Viewer Tests:** Awaiting ContentCache/PersistentCache implementation in Rust viewer

**‚ùå Known Failing Tests** (under investigation):
- `test_persistent_cache_bandwidth.py`: Requires viewer logStats() call fix (see TEST_TRIAGE_FINDINGS.md)
- `test_persistent_cache_eviction.py`: Requires viewer logStats() call fix
- `test_cache_parity.py`: Requires viewer logStats() call fix
- `test_cache_simple_poc.py`: Requires viewer logStats() call fix
- `test_cpp_limited_encodings.sh`: Requires DISPLAY environment fix
- `test_cachedrect_init_propagation.py`: Test obsolete (tests old ContentCache when PersistentCache is default)
- `run_baseline_rfb_test.py`: Outdated FBU count threshold
- `run_contentcache_test.py`: Unbounded waits cause timeout

**See**: `TEST_TRIAGE_FINDINGS.md` for detailed root cause analysis and fixes

## Architecture

**VNC-in-VNC Setup**: Two TigerVNC servers run simultaneously:
- **Display :998** (port 6898): Content generation server with automated desktop interactions
- **Display :999** (port 6899): Nested VNC server running an internal viewer connected to :998

External test viewers connect to :999 and experience the ContentCache protocol messages generated by :999 based on content from :998.

## Requirements

### Platform Support

- Recommended and supported: Linux (Ubuntu/Debian/Fedora)
- macOS: Not officially supported for e2e due to lack of Xtigervnc server and X11 WM stack by default. If you must run on macOS, use a Linux VM/container or a remote Linux host.

### System Packages (Linux)

**Required**:
```bash
sudo apt-get install tigervnc-standalone-server tigervnc-server \
  xterm openbox xsetroot wmctrl xdotool
```

**Optional** (for screenshot comparison):
```bash
sudo apt-get install xvfb x11-apps imagemagick
```

**Fonts** (for consistent rendering):
```bash
sudo apt-get install xfonts-base xfonts-75dpi xfonts-100dpi
```

### macOS Notes (if you still want to try locally)

Running the e2e suite on macOS is not recommended. If you still want to experiment:

- Install XQuartz and some tools via Homebrew (availability varies):
  ```bash
  brew install --cask xquartz
  brew install openbox wmctrl xdotool
  # Xtigervnc (server) is generally unavailable on macOS; use Linux instead
  ```
- Recommended alternative: run the e2e tests inside a Linux VM or on a remote Linux host.

### Build Directory and Auto-Build Behaviour

The e2e framework uses a single **build directory** (referred to as `BUILD_DIR`) to
locate all test binaries:

- By default, `BUILD_DIR` is `build` under the project root.
- You can override it by setting the `BUILD_DIR` environment variable (e.g.
  `BUILD_DIR=build-debug`) or by using `--build-dir` when calling `run_tests.sh`.

All server and viewer detection is based on this directory:

- **C++ viewer**: `BUILD_DIR/vncviewer/njcvncviewer`
- **Rust viewer**: `BUILD_DIR/vncviewer/njcvncviewer-rs` (symlink) or
  `rust-vnc-viewer/target/release/njcvncviewer-rs`
- **Custom server (Xnjcvnc)**: `BUILD_DIR/unix/xserver/hw/vnc/Xnjcvnc` (with a
  convenience symlink at `BUILD_DIR/unix/vncserver/Xnjcvnc`)

The e2e preflight routines will automatically build outdated or missing
binaries as needed:

- If the C++ viewer is missing, `preflight_check_cpp_only()` and
  `preflight_check()` run:

  ```bash
  make viewer
  ```

- If the Rust viewer is missing, `preflight_check()` runs:

  ```bash
  make rust_viewer
  ```

- If a local `Xnjcvnc` server binary exists in `BUILD_DIR` but is **older than
  the latest git commit**, the framework runs:

  ```bash
  make server
  ```

  before using it in tests. This keeps the custom server in sync with the
  current source tree without requiring manual rebuilds on every change.

Platform-specific behaviour:

- **Linux**: When a test explicitly requests the local server
  (`server_choice='local'`), the framework requires that an executable
  `Xnjcvnc` exists under `BUILD_DIR`. If it does not, the test fails fast with
  a clear `PreflightError` suggesting `make server`.
- **macOS**: The custom `Xnjcvnc` server is not currently supported. If a test
  requests `server_choice='local'` but no `Xnjcvnc` is available, the
  framework falls back to the system `Xtigervnc` with a warning, so
  viewer-focused tests can still run.

### TigerVNC Viewers (Summary)

If you prefer to build explicitly instead of relying on auto-build, you can
still run:

```bash
# C++ viewer
make viewer

# Rust viewer
make rust_viewer
```

### Safety Notes

‚ö† **CRITICAL**: This test framework **NEVER touches** production VNC servers on displays :1, :2, or :3. It only manages processes it starts on high-numbered displays (:998, :999).

All processes are launched in their own process groups and tracked explicitly. The framework never uses broad `pkill` commands.

## Usage

### Standalone Execution

```bash
# Basic run (default 90 second scenario)
python3 tests/e2e/run_contentcache_test.py

# Verbose output
python3 tests/e2e/run_contentcache_test.py --verbose

# Custom duration
python3 tests/e2e/run_contentcache_test.py --duration 120

# Custom displays/ports
python3 tests/e2e/run_contentcache_test.py --display1 900 --port1 6800 \
  --display2 901 --port2 6801
```

## Server Modes

- `system`: Use system-installed Xtigervnc
- `local`: Use project build `build/unix/vncserver/Xnjcvnc` if present
- `auto` (default): Run `system` and also `local` if available

CLI:
```bash
# Run system and local and compare
./run_contentcache_test.py --server-modes system,local
```

### CTest Integration

```bash
# Run via CTest
ctest --test-dir build -R e2e_contentcache -V

# Run all e2e tests
ctest --test-dir build -L e2e --output-on-failure
```

## Test Flow

1. **Preflight**: Check dependencies (Xtigervnc, xterm, wmctrl, viewers, etc.)
2. **Start :998**: Launch content generation server + window manager + session
3. **Start :999**: Launch nested VNC server + window manager
4. **Internal viewer**: Start C++ viewer in :999 connecting to :998 (logs suppressed)
5. **C++ baseline**: Run external C++ viewer connecting to :998, capture logs
6. **Scenario**: Execute automated desktop interactions on :998 (xterm-based deterministic content)
7. **Rust candidate**: Replay scenario with external Rust viewer, capture logs
8. **Repeat per server mode**: Run the above for each server mode (system Xtigervnc, local Xnjcvnc)
9. **Comparison**: Parse logs and compare metrics across viewers and server modes
10. **Cleanup**: Gracefully terminate all processes

## Expected Log Patterns

### ContentCache Protocol Messages

**C++ viewer**:
```
DecodeManager: Cache hit for ID 12345: blitting 64x64 to [100,100-164,164]
DecodeManager: Cache miss for ID 67890, requesting from server
DecodeManager: Storing decoded rect [200,200-264,264] with cache ID 11111
```

**Rust viewer** (similar):
```
[INFO] ContentCache hit: cache_id=12345 rect=[100,100,64,64]
[INFO] ContentCache miss: cache_id=67890, sending request
[INFO] Stored decoded rect with cache_id=11111
```

### ARC Statistics

End-of-session summary:
```
Client-side ContentCache statistics:
  Protocol operations (CachedRect received):
    Lookups: 1523, Hits: 1234 (81.0%)
    Misses: 289
  ARC cache performance:
    T1 (recency): 450 entries, T2 (frequency): 784 entries
```

## Validation Criteria

The test **passes** if:
- ‚úì No crashes or fatal errors
- ‚úì Cache hit rate within ¬±2% (absolute percentage points)
- ‚úì Protocol message counts within ¬±5% (`CachedRect`, `CachedRectInit`, `RequestCachedData`)
- ‚úì ARC T1/T2 balance within ¬±10%
- ‚úì Framebuffer screenshots pixel-identical (if Xvfb available)

The test **fails** if:
- ‚úó Crash or hang during execution
- ‚úó Hit rate divergence > 2%
- ‚úó Protocol message count divergence > 5%
- ‚úó Parsing errors or corrupted logs

## Known Issues (November 2025)

### Missing Bandwidth Statistics in Viewer Output

**Issue**: Test failures in bandwidth-related tests (`test_persistent_cache_bandwidth.py`, etc.) due to missing log output.

**Root Cause**: The C++ viewer (`vncviewer/njcvncviewer`) never calls `DecodeManager::logStats()` on shutdown, so bandwidth statistics are collected but never printed.

**Evidence**: PersistentCache protocol is working correctly - logs show:
- Client receives `PersistentCachedRectInit` messages (stores)
- Client receives `PersistentCachedRect` messages (cache hits)
- Bandwidth tracking functions are called (`trackPersistentCacheRef`, `trackPersistentCacheInit`)
- But end-of-session summary is never printed

**Impact**: Tests expect output like:
```
Client-side PersistentCache statistics:
  PersistentCache: 517 KiB bandwidth saving (99.7% reduction)
```

But this output never appears because `logStats()` isn't called.

**Fix Required**: Add `decode->logStats()` call in `vncviewer/CConn.cxx` destructor or disconnect handler (similar to how server calls `encodeManager->logStats()` in `VNCServerST`).

**Workaround**: None for automated tests. Manual verification can be done by inspecting detailed debug logs for cache hit/miss messages.

**Status**: Fix planned - 5-10 line code change in viewer shutdown path.

---

## Troubleshooting

### Port Conflicts

**Error**: `ERROR: Port 6898 already in use`

**Solution**: Check for existing processes:
```bash
lsof -i :6898
# If found, stop the conflicting process or use different ports:
python3 tests/e2e/run_contentcache_test.py --port1 7000 --port2 7001
```

### Display Conflicts

**Error**: `ERROR: Display :998 already in use`

**Solution**:
```bash
ls /tmp/.X11-unix/X998
# If exists:
rm /tmp/.X11-unix/X998  # Only if you're sure it's stale
# Or use different display:
python3 tests/e2e/run_contentcache_test.py --display1 950 --display2 951
```

### Window Manager Fails to Start

**Error**: `ERROR: Window manager failed to start`

**Solution**: Install openbox or try fluxbox:
```bash
sudo apt-get install openbox
# Or:
sudo apt-get install fluxbox
python3 tests/e2e/run_contentcache_test.py --wm fluxbox
```

### Low Hit Rate

**Symptom**: Test passes but hit rate is < 20%

**Causes**:
- Scenario duration too short (not enough repeated content)
- ContentCache disabled on server
- MinRectSize threshold too high

**Solution**:
```bash
# Increase duration for more cycles
python3 tests/e2e/run_contentcache_test.py --duration 180

# Check server parameters (EnableContentCache=1, ContentCacheMinRectSize=4096)
```

### Screenshot Differences

**Error**: `Framebuffer comparison FAIL: 1234 pixels differ`

**Causes**:
- Font rendering variations (different font packages installed)
- Anti-aliasing differences
- Timing issues (windows not fully rendered)

**Solution**:
```bash
# Install consistent fonts
sudo apt-get install xfonts-base xfonts-75dpi xfonts-100dpi

# Increase quiet period in scenarios.py (wait_idle after scenario)
```

If pixel-perfect comparison is not critical, the test can still pass on log comparison alone.

### Missing Dependencies

**Error**: `PreflightError: Required binary not found: xdotool`

**Solution**: Install missing packages as listed in Requirements section above.

## Specific Bug Tests

### CachedRectInit Propagation Test

**Issue**: Server has ContentCache hits but sends 0 `CachedRect` references to clients.

**Test**: `test_cachedrectin it_propagation.py`

Validates that when the server has a cache hit, it properly communicates it to the client via either:
- `CachedRect` (if client knows the cacheId)
- `CachedRectInit` (if client doesn't know the cacheId yet)

**Usage**:
```bash
# Server-side validation only
python3 tests/e2e/test_cachedrectin\ it_propagation.py --display 998 --port 6898

# Full protocol flow validation with viewer
python3 tests/e2e/test_cachedrectin\ it_propagation.py --display 998 --port 6898 --with-viewer

# Custom duration
python3 tests/e2e/test_cachedrectin\ it_propagation.py --duration 120 --with-viewer
```

**Test will FAIL if**:
- Server performs cache lookups but sends 0 references
- Client receives no `CachedRect` or `CachedRectInit` messages despite server cache hits

**Test will PASS if**:
- Server cache lookups result in cache reference messages being sent
- Client receives matching number of cache protocol messages

**Bug identified**: 2025-11-03 - Server queues `CachedRectInit` messages when client doesn't know a cacheId, but those queued messages are not being transmitted properly.

## Extending Scenarios

To add new test scenarios:

1. **Edit `scenarios.py`**: Add a new method to `ScenarioRunner`:
   ```python
   def my_custom_scenario(self, duration_sec: float = 60.0) -> dict:
       """Custom scenario description."""
       stats = {}
       # Your scenario implementation
       return stats
   ```

2. **Call from orchestrator**: Modify `run_contentcache_test.py` to invoke your scenario:
   ```python
   runner = ScenarioRunner(display=998, verbose=args.verbose)
   stats = runner.my_custom_scenario(duration_sec=args.duration)
   ```

3. **Test independently**: Run your scenario in isolation:
   ```python
   DISPLAY=:998 python3 -c "
   from scenarios import ScenarioRunner
   r = ScenarioRunner(998, verbose=True)
   r.my_custom_scenario(duration_sec=30)
   "
   ```

## Artifacts

All logs, screenshots, and reports are saved to:
```
tests/e2e/_artifacts/<timestamp>/
  logs/
    content_xtigervnc_998.log
    nested_xtigervnc_999.log
    content_wm.log
    nested_wm.log
    cpp_viewer.log
    rust_viewer.log
  screenshots/
    cpp_viewer.png
    rust_viewer.png
    fb_diff.png  # If framebuffers differ
  reports/
    e2e_contentcache_report.html
```

The artifact path is printed at the start of the test run.

## Implementation Status

### Completed Modules
- ‚úÖ `framework.py`: Server lifecycle, process tracking, preflight checks
- ‚úÖ `scenarios.py`: Automated content generation (xterm open/close/type cycles)
- ‚úÖ `log_parser.py`: Log parsing and normalization for ContentCache events
- ‚úÖ `comparator.py`: Tolerance-based metric comparison

### TODO: Remaining Work
- ‚è≥ `run_contentcache_test.py`: Main orchestrator (VNC-in-VNC setup, viewer execution, comparison)
- ‚è≥ `report.py`: HTML report generation with embedded screenshots
- ‚è≥ `CMakeLists.txt`: CTest integration
- ‚è≥ Screenshot comparison logic (ImageMagick integration)
- ‚è≥ Coredump capture on crash

To complete the implementation:
1. Implement the main orchestrator in `run_contentcache_test.py` following the flow described above
2. Add HTML report generation in `report.py`
3. Create `CMakeLists.txt` for CTest integration
4. Test the full pipeline end-to-end
5. Iterate on log parsing patterns as actual log format is refined

## Cross-Platform Testing

For testing the **macOS viewer against Linux server** or other cross-platform scenarios, see:

**‚Üí [CROSS_PLATFORM_TESTING.md](CROSS_PLATFORM_TESTING.md)** - Complete guide to cross-platform tests

Key scripts:
- `scripts/cachedrect_crosshost_debug_macos.sh` - Automated macOS‚ÜíLinux testing
- `scripts/server_only_cachedrect_test.py` - Remote server management
- `scripts/compare_cachedrect_logs.py` - Log analysis and comparison

## Contact

For questions or issues with the e2e test framework, refer to the project's WARP.md for ContentCache documentation and known issues.
